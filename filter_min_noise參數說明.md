# filter_min_noise 參數詳細解釋

## 核心概念

`filter_min_noise` 是**最小連續噪點數量閾值**。

**作用**：只有當**連續檢測到**的拖尾點數量 ≥ `filter_min_noise` 時，才會將這些點過濾掉。

---

## 為什麼需要這個參數？

### 避免誤刪

如果沒有這個參數，濾波器可能會：
- 誤刪單個或少量異常但**有效**的測量點
- 例如：掃描到小物體的邊緣，只有1-2個點，但這些點是有效的

### 拖尾的特徵

真正的拖尾通常是：
- **連續多個點**（例如 3-10 個點以上）
- 這些點都滿足拖尾的幾何特徵

---

## 工作原理（策略 1：角度距離法）

### 流程示意圖

```
掃描點序列：
點1 點2 點3 點4 點5 點6 點7 點8 點9 點10 ...
 │   │   │   │   │   │   │   │   │   │
檢測：每個點是否符合拖尾特徵（距離和角度都小於閾值）

示例：
點1: 正常點    ✅
點2: 正常點    ✅
點3: 拖尾點    ⚠️  (startI = 3)
點4: 拖尾點    ⚠️  (連續 2 個)
點5: 拖尾點    ⚠️  (連續 3 個)
點6: 正常點    ✅  (拖尾結束，判斷：3 >= minNoise ? 過濾 : 保留)
點7: 正常點    ✅
點8: 拖尾點    ⚠️  (startI = 8)
點9: 拖尾點    ⚠️  (連續 2 個)
點10: 正常點   ✅  (拖尾結束，判斷：2 >= minNoise ? 過濾 : 保留)
```

### 代碼邏輯

```cpp
int startI = -1;  // 標記拖尾起始點位置

for (每個點 i) {
    if (點i 符合拖尾特徵) {
        if (還沒開始記錄拖尾) {
            startI = i;  // 標記拖尾開始位置
        }
        // 繼續檢查下一個點
    }
    else {
        // 拖尾序列結束了
        if (已經開始記錄拖尾 && (i - startI >= minNoise)) {
            // 連續噪點數量 ≥ minNoise
            // 過濾從 startI 到 i 的所有點
            for (j = startI; j <= i; j++) {
                標記為噪點並過濾;
            }
        }
        // 如果連續噪點 < minNoise，不做任何處理（保留這些點）
        startI = -1;  // 重置
    }
}
```

---

## 實際例子

### 例子 1：filter_min_noise = 3

**掃描結果**：
```
點1: 正常點 (距離 2.0m)    ✅ 保留
點2: 正常點 (距離 2.1m)    ✅ 保留
點3: 拖尾點 (距離 0.05m)   ⚠️  開始計數
點4: 拖尾點 (距離 0.06m)   ⚠️  連續 2 個
點5: 正常點 (距離 2.0m)    ✅  序列結束，共 2 個 < 3 → **保留** ✅
點6: 正常點 (距離 2.1m)    ✅ 保留
點7: 拖尾點 (距離 0.05m)   ⚠️  開始計數
點8: 拖尾點 (距離 0.06m)   ⚠️  連續 2 個
點9: 拖尾點 (距離 0.07m)   ⚠️  連續 3 個
點10: 正常點 (距離 2.0m)   ✅  序列結束，共 3 個 >= 3 → **過濾** ❌
```

**結果**：
- 點3、點4：只有 2 個連續拖尾點 < 3，**保留**（可能是小物體）
- 點7、點8、點9：有 3 個連續拖尾點 >= 3，**過濾**（確認是拖尾）

---

### 例子 2：filter_min_noise = 1（不推薦）

**掃描結果**：
```
點1: 正常點    ✅ 保留
點2: 拖尾點    ⚠️  1 個 >= 1 → **過濾** ❌（可能誤刪！）
點3: 正常點    ✅ 保留
點4: 正常點    ✅ 保留
```

**問題**：
- 可能誤刪單個有效的異常點（例如小物體邊緣）

---

### 例子 3：filter_min_noise = 5（保守）

**掃描結果**：
```
點1: 正常點    ✅ 保留
點2: 拖尾點    ⚠️  1 個 < 5 → **保留**
點3: 拖尾點    ⚠️  2 個 < 5 → **保留**
點4: 拖尾點    ⚠️  3 個 < 5 → **保留**
點5: 拖尾點    ⚠️  4 個 < 5 → **保留**
點6: 拖尾點    ⚠️  5 個 >= 5 → **過濾** ❌
```

**結果**：
- 只有當連續拖尾點 ≥ 5 個時才過濾
- 可能會保留一些輕微的拖尾

---

## 視覺化對比

### 小物體邊緣（應該保留）

```
        雷達原點
           ●
           │
           │  小物體
           │    ● 點1 (正常)
           │    │
           │    │ 只有 1-2 個點
           │    ● 點2 (異常但有效)
           │
           │
           
如果 filter_min_noise = 3：
連續拖尾點 = 2 < 3 → **保留** ✅

避免誤刪小物體！
```

### 真正的拖尾（應該過濾）

```
        雷達原點
           ●
           │
           │  強光反射
           │    ● 點1 (拖尾)
           │    ● 點2 (拖尾)
           │    ● 點3 (拖尾)
           │    ● 點4 (拖尾)
           │    ● 點5 (拖尾)
           │    ● 點6 (拖尾)
           │
           
如果 filter_min_noise = 3：
連續拖尾點 = 6 >= 3 → **過濾** ❌
```

---

## 策略 1 vs 策略 2

### 策略 1（角度距離法）

**使用 `filter_min_noise`** ✅
- 檢測連續拖尾點序列
- 只有連續數量 ≥ `minNoise` 才過濾
- 會統計連續符合拖尾特徵的點
- 如果連續點數 < `minNoise`，保留這些點

**代碼邏輯**：
```cpp
if (i - startI >= minNoise) {  // 檢查連續點數量
    // 過濾這些點
}
```

### 策略 2（截距法）⚠️ 重要

**不使用 `filter_min_noise`** ❌
- 每個符合條件的點對都會被**立即標記為噪點**
- **不檢查連續性**
- 只要截距 < `filter_max_dist`，就直接過濾
- **注意**：即使設置了 `filter_min_noise`，策略 2 也不會使用它

**代碼邏輯**：
```cpp
if (min < maxDist) {  // 只有距離閾值檢查，沒有連續性檢查
    noises[i] = true;  // 立即標記為噪點
    noises[(i + 1) % size] = true;
}
```

**影響**：
- 策略 2 可能會過濾掉單個或少量異常點
- 如果您使用策略 2，`filter_min_noise` 參數實際上不起作用
- 需要通過調整 `filter_max_dist` 來控制過濾嚴格度

---

## 參數調整指南

### filter_min_noise = 1（非常激進）

```
任何 1 個拖尾點都會被過濾

優點：過濾最徹底
缺點：容易誤刪有效點（小物體邊緣）

風險：⚠️⚠️⚠️ 高風險誤刪
```

### filter_min_noise = 2（較激進）

```
連續 2 個拖尾點才會被過濾

優點：過濾較徹底
缺點：仍可能誤刪小物體

風險：⚠️⚠️ 中等風險
```

### filter_min_noise = 3（推薦）⭐

```
連續 3 個拖尾點才會被過濾

優點：平衡過濾效果和誤刪風險
缺點：輕微拖尾可能不會過濾

風險：⚠️ 低風險
```

### filter_min_noise = 5（保守）

```
連續 5 個拖尾點才會被過濾

優點：幾乎不會誤刪
缺點：可能保留輕微拖尾

風險：✅ 幾乎無風險誤刪
```

### filter_min_noise = 10（非常保守）

```
連續 10 個拖尾點才會被過濾

優點：完全不會誤刪
缺點：只過濾非常明顯的拖尾

風險：✅ 零風險誤刪
```

---

## 決策流程圖

```
開始掃描
    ↓
檢測到符合拖尾特徵的點
    ↓
是否開始記錄拖尾序列？
├─ 否 → startI = 當前位置，開始記錄
└─ 是 → 繼續記錄（計數+1）
    ↓
檢測到下一個點
    ↓
是否仍符合拖尾特徵？
├─ 是 → 繼續記錄
└─ 否 → 拖尾序列結束
    ↓
計算連續拖尾點數量：count = i - startI
    ↓
count >= filter_min_noise ?
├─ 是 → 過濾這些點 ❌
└─ 否 → 保留這些點 ✅（可能是小物體）
```

---

## 實際應用示例

### 場景 1：小物體邊緣

```
掃描到小物體的邊緣：
點1: 正常 (2.0m)
點2: 正常 (2.0m)
點3: 異常 (0.1m) ← 可能是邊緣點
點4: 異常 (0.12m) ← 可能是邊緣點
點5: 正常 (2.0m)

如果 filter_min_noise = 3：
連續異常點 = 2 < 3 → **保留** ✅

如果 filter_min_noise = 2：
連續異常點 = 2 >= 2 → **過濾** ❌（可能誤刪！）
```

### 場景 2：強光拖尾

```
強光產生的拖尾：
點1: 正常 (2.0m)
點2: 拖尾 (0.05m)
點3: 拖尾 (0.06m)
點4: 拖尾 (0.07m)
點5: 拖尾 (0.08m)
點6: 拖尾 (0.09m)
點7: 正常 (2.0m)

如果 filter_min_noise = 3：
連續拖尾點 = 5 >= 3 → **過濾** ✅
```

---

## 關鍵理解

| 項目 | 說明 |
|------|------|
| **不是** | 總共檢測到的拖尾點數量 |
| **而是** | **連續**拖尾點的最小數量 |
| **作用** | 防止誤刪少量異常但有效的點 |
| **預設值** | 3 個點 |
| **意義** | 拖尾通常是連續多個點，不是單個點 |

### 記憶要點

1. **值越小** = 更容易過濾（但可能誤刪）
2. **值越大** = 更保守過濾（但可能保留拖尾）
3. **3 個點** = 平衡選擇，推薦使用

---

## 與其他參數的配合

### 配合 filter_max_dist

```
filter_max_dist = 0.05（嚴格）
filter_min_noise = 5（保守）

→ 只過濾非常明顯且連續的拖尾
→ 平衡過濾效果和誤刪風險
```

### 配合 filter_max_dist

```
filter_max_dist = 0.10（寬鬆）
filter_min_noise = 2（激進）

→ 過濾較多可能的拖尾點
→ 需要仔細觀察是否誤刪
```

---

## 總結

`filter_min_noise` 是**安全機制**，用於：
- ✅ 區分「真正的拖尾」（連續多個點）
- ✅ 避免誤刪「偶發異常點」（1-2 個點）
- ✅ 保護小物體的邊緣點

**推薦設置**：
- `filter_min_noise = 3`（平衡）
- 如果頻繁誤刪小物體 → 增大（例如 5）
- 如果仍有拖尾沒過濾 → 減小（例如 2）

